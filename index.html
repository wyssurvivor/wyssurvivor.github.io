<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="I&apos;m concerned with questions, not simply of immutable truth, but of practice and expedience.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ryan Wang">
<meta property="og:url" content="http://wyssurvivor.github.io/index.html">
<meta property="og:site_name" content="Ryan Wang">
<meta property="og:description" content="I&apos;m concerned with questions, not simply of immutable truth, but of practice and expedience.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ryan Wang">
<meta name="twitter:description" content="I&apos;m concerned with questions, not simply of immutable truth, but of practice and expedience.">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Ryan Wang </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ryan Wang</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Standing on Shoulders of Giants</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/06/20170506-https-theory/" itemprop="url">
                  20170506-https-theory
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-05-06T10:46:55+08:00" content="2017-05-06">
              2017-05-06
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="https原理">https原理</h2><p><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="external">参考</a></p>
<p><img src="http://images2015.cnblogs.com/blog/366784/201601/366784-20160127222221785-258650029.png" alt="流程图"></p>
<p>https的验证流程：</p>
<ul>
<li>客户端把自己支持的协议版本、加密算法、压缩算法等信息传递给服务器端。</li>
<li>服务器端接收到请求后对这些属性进行选择，如果不能找到支持的协议组件，就断开连接。如果能够支持，就把证书传给客户端。证书中包涵公钥、ca机构，网址，失效日期。</li>
<li>客户端接收到响应之后会验证证书的合法性并且声称一个随机的key，并用公钥对随机数加密，再用随机的key对握手信息进行加密，这些信息一并发送给服务器端。</li>
<li>服务器端收到请求后使用证书中的公钥对应的私钥解密，获取了浏览器生成的随记key，在用随机key解密获得握手信息</li>
<li>后面服务器端与客户端相互之间的交互全部使用这个随机的key进行加密，因为只有这两者知道这个key是什么。</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/20170430-redis-pipeline/" itemprop="url">
                  20170430-redis-pipeline
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-04-30T15:36:06+08:00" content="2017-04-30">
              2017-04-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/redis/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="redis_pipeline">redis pipeline</h2><p><a href="https://redis.io/topics/pipelining" target="_blank" rel="external">redis pipeline</a></p>
<p>redis是一种典型的服务器－客户端工作模式。客户端把想要执行的命令发送给服务器端，服务器端返回结果给客户端。<br>所以一个包含四个命令的序列的执行如下：</p>
<ul>
<li>Client:incr key 1</li>
<li>Server:1</li>
<li>Client:incr key 1</li>
<li>Server:2</li>
<li>Client:incr key 1</li>
<li>Server:3</li>
<li>Client:incr key 1</li>
<li>Server:4</li>
</ul>
<p>从客户端发送命令到客户端接受回复这一段时间，请求和回复在网络中传输，这个时间段是一个RTT（Round Trip Time）。如果是如上面这样的执行方式，那么执行完需要四个RTT。整个请求完成需要的时间比较长。redis 提供了一种优化的方案是redis pipeline。</p>
<p>对于redis pipeline，客户端可以在没有收到上一个请求的回复的时候就发起下一个请求。在这种模式下，你可以同时发送多个请求而不用等待回复，最终获得一个结果即可。这优点类似于网络中并行发送请求的样子。所以上面的例子在使用pipeline的情况下是这样工作的：</p>
<ul>
<li>Client:incr key 1</li>
<li>Client:incr key 1</li>
<li>Client:incr key 1</li>
<li>Client:incr key 1</li>
<li>Server:1</li>
<li>Server:2</li>
<li>Server:3</li>
<li>Server:4</li>
</ul>
<p>注意，pipeline模式中在服务器端需要存储这些请求以后续执行。因此，在使用pipeline的时候会额外消耗一些内存空间。所以如果客户端会发送大量的请求到redis server，就会导致消耗大量的内存空间。在这种情况下，使用各种数据类型的Batch操作是一种更好的方式，它不会消耗额外的空间。而且执行效率上来说，与pipeline的方式差不多，没有本质上的差别。</p>
<p>在java中使用Jedis</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withPipeline</span><span class="params">(Jedis redis)</span> </span>{
    redis.select(<span class="number">8</span>);
    redis.flushDB();
    <span class="keyword">long</span> start = System.currentTimeMillis();
    Pipeline pipe = redis.pipelined();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) {
        pipe.<span class="built_in">set</span>(<span class="string">"pk_"</span>+i, i+<span class="string">""</span>);
    }
    pipe.sync();
    <span class="keyword">long</span> end = System.currentTimeMillis();
    System.out.println(<span class="string">"with pipeline: "</span> + (end-start) + <span class="string">" milliseconds"</span>);
}
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withoutPipeline</span><span class="params">(Jedis redis)</span> </span>{
    redis.select(<span class="number">8</span>);
    redis.flushDB();
    <span class="keyword">long</span> start = System.currentTimeMillis();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) {
        redis.<span class="built_in">set</span>(<span class="string">"k_"</span>+i,i+<span class="string">""</span>);
    }
    <span class="keyword">long</span> end = System.currentTimeMillis();
    System.out.println(<span class="string">"with out pipeline: "</span> + (end-start) + <span class="string">" milliseconds"</span>);
}
</code></pre><p>在我自己机器上的执行结果是：</p>
<pre><code><span class="operator">with</span> out pipeline: <span class="number">895</span> <span class="built_in">milliseconds</span>
<span class="operator">with</span> pipeline: <span class="number">78</span> <span class="built_in">milliseconds</span>
</code></pre><p>可以看到使用pipeline还是能快挺多的</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/20170320-io-1/" itemprop="url">
                  20170320-io_1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-20T23:27:36+08:00" content="2017-03-20">
              2017-03-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="IO">IO</h2><p>一直以来对于io的一些概念比较模糊不清，最近看netty决定好好的理一下。要讨论io首先要区分同步／异步和阻塞／非阻塞这两组概念。</p>
<h3 id="同步和异步">同步和异步</h3><ul>
<li>同步是指一个任务需要等待依赖的任务完成，才能继续执行下去，这个任务的执行就是同步的。</li>
<li>异步就是一个任务的执行不需要等待依赖的任务完成就可以继续执行下去。</li>
<li>e.g. 一个同步的网络调用必须等待服务器端执行完了，调用端得到了返回结果，才能继续执行下午。而一个异步的网络调用不需要等待服务器端返回结果就能继续执行下去。至于服务器端的返回可以通过修改状态、通知和回调来通知调用者。</li>
</ul>
<h3 id="阻塞和非阻塞">阻塞和非阻塞</h3><ul>
<li>阻塞是指线程在等待消息返回时不能处理其它任务，则是阻塞的。</li>
<li>非阻塞是指线程在等待消息返回时可以转而去处理其它任务，当消息就绪时，再回来继续执行下去。</li>
<li>阻塞和同步是两个不同的概念。当一个同步调用在等待消息返回时，可以有两种情况：1.线程不能处理其它任务，那么就是同步阻塞的2.线程可以处理其它任务，那么就是同步非阻塞的。</li>
<li>异步阻塞和异步非阻塞也是存在的。我的理解是，当一个任务异步调用了另一个任务的时候，在得到消息返回之前可以是阻塞的也可以是非阻塞的。</li>
</ul>
<h3 id="操作系统的缓冲io">操作系统的缓冲io</h3><p>为了优化操作系统读写io的速度，在操作系统内核区域加了一块缓冲区。用户的read操作并不是直接从硬盘读数据，是把硬盘上的数据块复制到内核缓冲区中。如果要读取的数据不在内核缓冲区中，操作系统会把相应的数据块加入到请求队列中，然后挂起该进程，为其它进程服务。一段时间之后，操作系统把数据从硬盘读取到内核缓冲区中，然后从内核缓冲区读取到用户进程的缓冲区中，最后唤醒被挂起的进程。</p>
<p>类似的，当一个进程相要从socket读取数据时，先把数据从socket缓冲区复制到内核缓冲区中，然后从内核缓冲区复制到用户进程的缓冲区中。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/20170311-fix-a-strange-problem/" itemprop="url">
                  20170311-fix-a-strange-problem
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-03-11T23:34:19+08:00" content="2017-03-11">
              2017-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/coding-life/" itemprop="url" rel="index">
                    <span itemprop="name">coding life</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>去年为了我自己存储个人帐号密码的需要，就自己动手用pyqt写了一个mac上的app，用了存储我自己的用户名和密码。当时不用什么1password等app来存储这些信息是因为，作为一个程序员，我还是觉得自己写的app，所有东西都在我自己的掌控之下来的更有安全感一些。<br>然而，今晚出了点小麻烦，就当我想要打开这个app，记录一个我在某网站申请的帐号的时候，我发现这个app打不开了。macOS给的信息大致是这样的 “在打开sip.so的时候python报错”。WTF？黑人问好脸？苹果好歹也是个大厂，能不能在错误提示和汉语翻译这方面上点心。然后看详细的报错信息。。。还是放弃了，毕竟我是个很软的软件工程师，这种类似于汇编的东西实在是超出了我的能力范围。<br>于是就开始查是什么问题，由于苹果系统渣一样的错误提示，导致google不到有用的信息。于是就出google一下sip</p>
<pre><code>SIP is <span class="operator">a</span> tool that makes <span class="keyword">it</span> very easy <span class="built_in">to</span> <span class="built_in">create</span> Python bindings <span class="keyword">for</span> C <span class="operator">and</span> C++ libraries. It was originally developed <span class="built_in">to</span> <span class="built_in">create</span> PyQt, <span class="operator">the</span> Python bindings <span class="keyword">for</span> <span class="operator">the</span> Qt toolkit, but can be used <span class="built_in">to</span> <span class="built_in">create</span> bindings <span class="keyword">for</span> <span class="keyword">any</span> C <span class="operator">or</span> C++ library.
</code></pre><p>基本上就是说，sip能够使的python调用用C和C＋＋编写的程序库。想到PyQT应该是对QT的调用，想来也是需要这东西的。于是用homebrew查看了一下sip的安装信息</p>
<pre><code>/usr/local/Cellar/sip/<span class="number">4.16</span><span class="number">.9</span> (<span class="number">10</span> files, <span class="number">858.9</span>KB)
Poured from bottle on <span class="number">2015</span>-<span class="number">09</span>-<span class="number">14</span> at <span class="number">13</span>:<span class="number">31</span>:<span class="number">28</span>
/usr/local/Cellar/sip/<span class="number">4.19</span> (<span class="number">12</span> files, <span class="number">941.6</span>KB) *
Poured from bottle on <span class="number">2017</span>-<span class="number">03</span>-<span class="number">05</span> at <span class="number">15</span>:<span class="number">33</span>:<span class="number">39</span>
</code></pre><p>居然有两个版本，我在前几天安装octave的时候曾经运行过brew upgrade命令，一定是在那个时候更新了sip，导致与现在的QT版本不兼容而报错了。那么怎么修复呢？继续google，发现homebrew果然是个神奇，运行switch命令，切换版本，大功告成，程序又可以正常运行了。</p>
<pre><code>brew <span class="keyword">switch</span> sip <span class="number">4.16</span><span class="number">.1</span>
</code></pre><p>在写这篇文章的时候，出现了同样的问题，hexo报错显示node版本不兼容，想都不用想，homebrew切换一下版本，搞定。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/20/20170220-coroutine/" itemprop="url">
                  20170220-coroutine
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2017-02-20T21:26:36+08:00" content="2017-02-20">
              2017-02-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/develop/" itemprop="url" rel="index">
                    <span itemprop="name">develop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="协程_coroutine">协程 coroutine</h2><p>最近频繁的听说到 “协程” 这个词，花了一段时间肤浅的研究了一下。对于 “它是一个什么东西” 有了一个大概的了解。</p>
<p>from wiki<br>    Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.</p>
<p>协程是一种为了实现非抢占式多任务的程序组件，它会有多个进入点，在这些进入点可以挂起休眠和恢复执行。协程非常适合用来实现我们常见的一些程序组件，例如协作式任务、异常、事件循环、迭代器、无限列表和管道。</p>
<p>在我的理解中，协程本质上是一些程序的执行序列，它允许开发者使用它实现多任务协作完成某件事情。只是，与使用线程不同的是，在使用线程完成多任务开发时，会有多个线程分享cpu时间、在线程切换的时候会有上下文相关的操作，而且，在线程之间需要加锁来处理线程的竞态问题。<br>反观协程，自始至终只有一个协程存在，就算有其他协程也是出于休眠状态。协程在执行完一部分程序之后，可以切换到另外一个协程执行程序，而这个切换非常的轻量级。协程只能主动放弃执行把执行权给指定的协程，而不能被抢占，因此它是一个非抢占式的。这样意味着，有别于线程的是，协程的执行顺序是完全已知的并且可控的。</p>
<p>线程是操作系统的一个概念，而协程是基于程序语言实现的特性，因此是用户态的。因此，实际上，协程是一种用户态的线程，相当于你在现有程序语言的基础上，自己开发一套，实现程序的调度。</p>
<p>前面也说到，既然是切换，程序执行的状态需要记录下来，协程在实现的时候需要一块特殊的内存地址范围存放信息，c语言中有类似的机制setjump／longjump和ucontext。太过于底层，可以在参考文献中查看。</p>
<p>以上仅仅是我自己的理解</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/10/20160910-docker/" itemprop="url">
                  20160910-docker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-09-10T17:34:24+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="初探docker">初探docker</h2><p>docker引擎技术核心包括镜像和容器。<br>镜像是一个文件系统，没有状态。容器是景象的一个运行中的实例。如果运行下面的命令：<br>    docker run hello-world</p>
<p>docker引擎会做：</p>
<ul>
<li>检查是否有-world景象</li>
<li>如果没有，从Docker Hub下载该镜像到本地</li>
<li>加载镜像并运行</li>
</ul>
<p>一个镜像能够干更多的更复杂的事情。一个镜像可以运行像数据库这样复杂的软件来管理数据。</p>
<h3 id="Hello_World_in_a_Docker">Hello World in a Docker</h3><h4 id="Run_a_Hello_World">Run a Hello World</h4><p>在docker中你可以运行自己的程序，构造自己想要的任何东西。运行程序使用docker run命令。<br>    docker run ubuntu /bin/echo ‘hello world’</p>
<p>在这个例子中</p>
<ul>
<li>docker run 运行了一个容器</li>
<li>ubuntu 是要运行的镜像</li>
<li>/bin/echo 是新容器中运行的命令</li>
</ul>
<h4 id="Run_an_interactive_container">Run an interactive container</h4><p>使用如下命令运行一个交互式的容器<br>    docker run -t -i ubuntu /bin/echo</p>
<p>在这个例子中－t flag表示在容器中运行了一个terminal，－i flag允许你以交互的方式运行容器。</p>
<h4 id="Start_a_daemonized_Hello_world">Start a daemonized Hello world</h4><p>执行下面的命令创建一个容器并以daemon的方式运行<br>    docker run -d ubuntu /bin/sh -c “while true;do echo hello world;sleep 1;done”</p>
<p>-d flag表示以daemon的方式运行。命令运行后会有一个container ID。可以使用这个ID来查看daemon容器中的信息。<br>    docker ps</p>
<p>docker ps可以看到容器在的运行状态。然而容器是否如我们期望的那样运行着？可以通过下面命令查看。<br>    docker logs container_name/container_id</p>
<p>运行下面的命令停止容器运行<br>    docker stop container_name/container_id</p>
<h3 id="Run_a_simple_application">Run a simple application</h3><h4 id="Running_a_web_application_in_Docker">Running a web application in Docker</h4><p>运行以下命令运行一个web应用<br>    docker run -d -P training/webapp python app.py</p>
<p>－P flag 告诉Docker把相应的容器内的port绑定到host机的port上。你也可以在运行的时候用－p选项指定要绑定到的本机端口。<br>    docker run -d -p 80:5000 training/webapp python app.py</p>
<h4 id="A_network_port_shortcut">A network port shortcut</h4><p>使用docker port命令查看某个容器的某个端口的绑定情况<br>    docker port contaniner_name port_number</p>
<h3 id="Build_your_own_images">Build your own images</h3><p>镜像是容器的基础。每次使用docker run命令的时候都会告诉docker你要使用的镜像名称。在之前的命令中使用的镜像都是已经存在的镜像。</p>
<h4 id="Listing_images_on_the_host">Listing images on the host</h4><p>使用如下命令：<br>    docker images</p>
<p>可以看到本机上有的所有的镜像的信息，包括镜像名称，tag，镜像ID，创建时间、大小等。</p>
<h4 id="Getting_a_new_image">Getting a new image</h4><p>如果docker发现你要使用的镜像在本地没有，就会自动下载镜像到本地。你也可以预先自己下载好镜像，使用：<br>    docker pull centos</p>
<p>可以在打印出的信息中看到镜像的每个文件层都被下载下来了，之后就可以方便的使用了。</p>
<h4 id="Creating_our_own_images">Creating our own images</h4><p>如果发现没有现成的镜像能够满足你的需求，那么可以自己来创建一个容器。创建容器有两种方式：</p>
<ul>
<li>在一个容器的基础上做修改更新然后提交结果并生成一个镜像</li>
<li>通过使用Dockerfile创建一个容器</li>
</ul>
<h5 id="Updating_and_committing_an_image">Updating and committing an image</h5><p>为了更新一个镜像，首先运行一个镜像<br>    docker run -ti training?sinatra /bin/bash</p>
<p>在交互式的命令行中做修改更新：<br>    apt-get install -y ruby2.0-dev<br>    gem2.0 install json</p>
<p>执行完毕之后使用exit退出。现在有一个你修改过的容器，你可以通过以下命令把该容器的一份拷贝生成镜像。<br>    docker commit -m “” -a “” container_id image_name</p>
<h5 id="Building_an_image_from_a_Dockerfile">Building an image from a Dockerfile</h5><p>创建一个目录和一个Dockerfile。Dockerfile中每一条命令都会创建一个文件层<br>    FROM ubuntu:14.04<br>    MAINTAINER xxx <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x78;&#120;&#x78;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#x78;&#120;&#x78;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a><br>    RUN apt-get update &amp;&amp; apt-get install -y ruby ruby-dev<br>    RUN gem install sinatra</p>
<p>有了Dockerfile使用docker build创建镜像<br>    docker build -t container_name .</p>
<p>通过输出可以个看到，docker 会顺序的一条一条的执行Dockerfile中的命令。每个命令会创建一个新的容器，执行指令并提交修改，就像docker commit的工作原理一样</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/28/20160828-LSM-Tree/" itemprop="url">
                  20160828-LSM-Tree
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-08-28T21:06:37+08:00" content="2016-08-28">
              2016-08-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index">
                    <span itemprop="name">bigdata</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="LSM树">LSM树</h2><p>与B＋树和ISAM相比，LSM树的架构设计拥有更好的写入性能。它通过消除原地更新操作来提高写入性能。其核心思想是，硬盘写入中的一个老问题，相比于随机写入，顺序写入更快。不管是机械硬盘还是固态硬盘，这种差距都存在。<br>从这种现状出发，我们考虑一下：如果我们对写的吞吐量感兴趣，那么能够使用哪些方法？一个好的出发点是直接向文件后面添加数据。这种方法通常被称为打日志或者堆文件，它是完全的顺序写入的可以提供非常快的写入性能，能够达到理论上的磁盘写入速度。<br>受益于其简单性和良好的写入性能，写日志的方法在大数据领域成为一种流行的方法。然而，它也有明显的缺陷。从日志中随机读将消耗比写入操作多的多的时间，包括反向的扫描，直到找到key为止。<br>这意味着打日志只适用于读负载量小的情况下，其数据作为一个整体被访问，例如数据库的预写日志，或者通过已知的偏移量访问，例如消息系统kafka。<br>所以我们需要的不止是打日志的方法来更高效的做复杂的读操作，如根据key访问操作或者反问搜索。现在大致有四个方法能帮我们：二分搜索、hash、B＋和外部文件。</p>
<ul>
<li>对于按key顺序存储的文件</li>
<li>hash，把数据通过hash函数分到不同的篮子中，之后可以直接访问这些数据。</li>
<li>B＋，使用可查询文件组织如B＋树或者ISAM</li>
<li>外部文件，数据存储在log中，并且另外创建索引加速读取。</li>
</ul>
<p>上面这些方式能够提高读的性能，然而由于加入了一些顺序，导致写的性能又下降了。<br>这其中有几个问题。每一次写操作需要两次io操作，一次读区页信息另一次是写入数据。这并不是如打日志一样，一次写入操作就可以完成。<br>更加糟糕的是，我们每次更新操作的时候都要更新hash或者index。更新这些信息意味着更新文件系统的其它部分。这些写入操作又是原地写入操作，是随机写。<br>一种可行的方式是把索引写入日志，并且保存在内存中。<br>另外一方面这个方案还存在扩展性问题，特别是如果你有很多小数据。如果你的数据是一些简单的数字那么索引将会比数据本身还要大。现在有很多产品一经对这一问题妥协了。<br>因此，就出现了LSM树，LSM树以另外一种方式使用上面的四种优化措施。它是完全以硬盘为中心的，需要一些额外的内存来提高效率。其写入的性能还是依靠日志的方式保证的。它的缺点时，相较于B＋树，读性能还是稍微弱了一点。<br><img src="http://7xojgs.com1.z0.glb.clouddn.com/Journal6.png" alt="lsm tree"></p>
<h3 id="基本的LSM算法">基本的LSM算法</h3><p>LSM树的理论非常简单。它并不是用一个大的索引结构存储，而是用一些小的索引文件顺序的存储一批写入操作。所以，每个文件包含在一个时间段内的一批修改。每个文件。每个文件都是排序的，因此后面的搜索会很快。这些文件是不可修改的。新的修改会被写入到新的文件中。读操作会检查所有的文件。这些文件会周期性的做合并操作以降低文件的总量。<br>让我们看一下细节。当有写入操作到来时，被加入到内存中的一段缓存去中，这个区域通常使用树（红黑树等）来实现，以保证key的有序性。在写入这个内存表之前，写入操作会先被添加到一个预写日志的末尾，用来从系统崩溃中恢复。当这个缓冲区满了之后，这些排序后的数据会被写道硬盘上的一个文件中。这个过程随着写入操作的到来不断重复着。因为这些文件不能被修改，因此，整个系统是顺序写入的。<br>所以，随着越来越多的数据存储到系统中，会产生越来越多的不可修改的，排序的文件被创建。每一个代表了一些更改的小集合。<br>因为老的文件不会被更新，多余的项背创建以覆盖老的数据。这产生了一些冗余。<br>系统中骑行的做压缩操作。压缩操作时会选择一些文件并把它们合并成一个文件，把多余的更新和删除指令丢弃。这个压缩操作能够消除前面提到的冗余，更重要的是，能够使读的性能保持良好。因为每个文件都是排序好的，因此这个合并过程非常快。<br>当一个读请求到来时，系统首先检查内存表。如果在内存表中没找到key，系统会一个一个的检查硬盘上的文件，以逆时间顺序，直到key被找到。每个文件是有序的，因此是可查询的。然而，读操作会随着文件个数的增长变的越来越慢，因为每个文件都会被检索一边。<br>所以，LSM树的读性能弱一些。幸运的是，有一些优化方法能够改善读的性能。最常见的方法是在内存中建立索引，可以更快的接近查询的key。LevelDB，RocksDB和BigTable在每个文件后面加索引。这种方式比直接二分搜索要快。<br>即使在每个文件中加索引，读操作依然会随着文件的增多而变的缓慢。这可以通过定期的合并操作解决。这种压缩操作能够控制文件数量，搓耳控制读的性能在可接受的范围内。<br>即使压缩文件，读操作依然需要访问很多文件。大部分的实现会使用bloom filter提高性能。<br>所以，从写的角度来看，所有的写操作被聚合在一起并被顺序的写入到一些块中。<br><img src="http://7xojgs.com1.z0.glb.clouddn.com/Journal31.png" alt="lsm tree"></p>
<h3 id="Compaction">Compaction</h3><p>为了控制LSM树的读性能，减少文件的个数是恨重要的。压缩的过程优点类似于垃圾收集的过程。<br>当一定数量的文件被创建之后，例如5个文件，每个文件10行，它们被合并到一个文件中，50行。<br>最终有5个50行的文件，这是，这5个文件被合并成一个文件。这个过程一只持续下去产生越来越大的文件<br><img src="http://7xojgs.com1.z0.glb.clouddn.com/Journal2.51.png" alt="lsm tree"></p>
<h3 id="Levelled_Compaction">Levelled Compaction</h3><p>新的实现方式，如LevelDB、RocksDB和Cassandra，使用分层的文件压缩解决这个问题。这降低了文件的数量并且降低了一次压缩的影响范围。<br>这个level－based方法有连个改进：</p>
<ul>
<li>每一层包涵一些文件并切保证，每一层的文件之间的key范围不会相互覆盖。因此，在一层中查找一个key只需要查找一个文件就行。第一层是个例外，文件的key范围可能会相互覆盖。</li>
<li>文件会被合并到高一层的文件中</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/06/20160806-mysql-transaction-isolation-level/" itemprop="url">
                  mysql-transaction-isolation-level
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-08-06T20:20:19+08:00" content="2016-08-06">
              2016-08-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="mysql事务隔离级别">mysql事务隔离级别</h2><p>事务隔离级别是数据库中的基础部分之一，对应acid四个特性中的i（isolation）。innodb引擎支持四种隔离级别：read uncommitted、read committed、repeatable read、serializable。每一种隔离级别都是在性能与可靠性、一致性之间做中和选择。Innodb默认的隔离级别是repeatable read。用户需要根据自己的实际需求来在这四种级别中做选择。</p>
<h3 id="read_uncommitted">read uncommitted</h3><p>在事务中做select操作的时候不加任何锁，因此读到的信息和可能是过时的，被其他transaction修改过的。也是说，这种隔离界别，不具有一致性，会出现脏读的情况。</p>
<h3 id="read_committed">read committed</h3><p>事务中的读操作是一致性读，并且每一次的读操作，都会获取到数据的最新快找。也就是说，在这种隔离级别下，多次读读到的内容可能是不一样的，也就是不可重复读的问题。<br>对于事务中的加锁读（select…for update or select …lock in share mode）、更新操作、删除操作，只在用到的行上加index lock，不加gap lock</p>
<h3 id="repeatable_read">repeatable read</h3><p>事务中的读是一致性读。在同一个事务中的重复读，读到的是第一次读的快照。因此，每一次读到的内容都一样，所以叫可重复读。<br>对于加锁读、更新操作、删除操作，加锁的类型和范围视情况而定。如果语句的搜索条件使用的是unique index，innodb只在相关的行上加锁。对于其他的情况，innodb会锁定所有扫描过的范围，使用gap lock或者next-key lock。</p>
<h3 id="serializable">serializable</h3><p>repeatable read会出现幻读的情况，serializable级别可以解决幻读。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/30/20160729-offer006/" itemprop="url">
                  20160729-offer006
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-30T15:55:51+08:00" content="2016-07-30">
              2016-07-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="剑指offer">剑指offer</h2><p>最近无聊，想把丢弃了很久的算法再捡起来，随便找了个网站，发现上面有剑指offer的题，就做了一些。</p>
<p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>我的思路：我的思路很简单，找到中位数，判断中位数是在哪个部分，然后缩小范围，到相应的范围去查找。代码如下：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span></span>{
<span class="keyword">if</span>(rotateArray.size()==<span class="number">1</span>){
    <span class="keyword">return</span> rotateArray[<span class="number">0</span>];
}
<span class="keyword">if</span>(rotateArray.size()==<span class="number">2</span>){
    <span class="keyword">return</span> rotateArray[<span class="number">0</span>]&gt;rotateArray[<span class="number">1</span>]?rotateArray[<span class="number">1</span>]:rotateArray[<span class="number">0</span>];
}
<span class="keyword">int</span> left=<span class="number">0</span>;
<span class="keyword">int</span> right=rotateArray.size()-<span class="number">1</span>;
<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;
<span class="keyword">if</span>(rotateArray[left]&gt;rotateArray[mid]){
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftVec(rotateArray.begin(),rotateArray.begin()+mid+<span class="number">1</span>);
    <span class="keyword">return</span> minNumberInRotateArray(leftVec);
}<span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&gt;rotateArray[right]){
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightVec(rotateArray.begin()+mid,rotateArray.end());
    <span class="keyword">return</span> minNumberInRotateArray(rightVec);
}<span class="keyword">else</span>{
    <span class="keyword">return</span> rotateArray[mid];
}

}
</code></pre><p>这一题《剑指offer》上的思路是这样的，也是二分法查找，然而是缩小两边两个指针的位置来确定最终的那个数的位置在哪。思路上应该是比我的思路要简单，我的思路在到范围缩小到只有两个数的时候，处理的比较机械，不能把它归到一个统一的思路下，不够优美。而且，我用的是递归的方法，算法跑起来应该会相对慢一些，启示不用递归也能做，就是懒，用了递归。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray2</span><span class="params">(<span class="keyword">int</span> *numbers,<span class="keyword">int</span> length)</span></span>{
<span class="keyword">if</span>(numbers==<span class="literal">NULL</span>||length&lt;=<span class="number">0</span>){
    <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"Invalid parametes"</span>);
}
<span class="keyword">int</span> index1=<span class="number">0</span>;
<span class="keyword">int</span> index2=length-<span class="number">1</span>;
<span class="keyword">int</span> indexMid=index1;
<span class="keyword">while</span> (numbers[index1]&gt;=numbers[index2]) {
    <span class="keyword">if</span>(index2-index1==<span class="number">1</span>){
        indexMid=index2;
        <span class="keyword">break</span>;
    }
    indexMid=(index1+index2)/<span class="number">2</span>;
    <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1]){
        index1=indexMid;
    }<span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2]){
        index2=indexMid;
    }
}
<span class="keyword">return</span> numbers[indexMid];
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/17/20160717-a-successful-git-branching-model/" itemprop="url">
                  20160717-a-successful-git-branching-model
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-17T13:48:48+08:00" content="2016-07-17">
              2016-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="A_successful_git_branching_model">A successful git branching model</h2><p>最近组里刚刚从svn迁移到了git，本以为自己对于git已经有足够的了解了，没想到真正与团队协作开发的时候还是碰到了一些问题，于是还是上网查了一些资料，继续学习。本文实际上是一篇<a href="http://nvie.com/posts/a-successful-git-branching-model/#creating-a-feature-branch" target="_blank" rel="external">A successful git branching model</a>的学习笔记。</p>
<p>不是说一定要完全按照这篇文章作者所描述的那样使用git，只是这篇文章是提供了一套挺完备的开发流程，能够引起我对于自己日常使用git的一些思考。根据这篇文章的介绍的branching经验方法，结合自己的实际情况，应该能够总结出一套更好的也是更适合自己的开发流程。</p>
<p><img src="http://7xojgs.com1.z0.glb.clouddn.com/git-model@2x.png" alt="branching pic"></p>
<p>上图基本上就是这个branching model的一个总览图，其中的思想基本上都在里面了。下面详细说明一下。</p>
<h3 id="main_branches">main branches</h3><p>在远程仓库中，有两条分支是始终存在的</p>
<ul>
<li>origin/master</li>
<li>origin/develop</li>
</ul>
<p>origin/master分支始终处于可上线状态或者已上线状态。origin／develop分支包含了开发者最新的修改。如果develop分支的代码都没有问题了，就可以合并到master分支了，真正合并的时候没这么简单，下面再说。</p>
<h3 id="supporting_branches">supporting branches</h3><p>为了协助团队成员间的并行开发、特性分支纪录、代码上线和快速bugfix，提供了supporting branches。所不同的是，这些分支并不是一直存在的，只要完成使命，就会被删掉。</p>
<ul>
<li>feature branches</li>
<li>release branches</li>
<li>hotfix branches</li>
</ul>
<p>这些分支都有其特殊的用途。</p>
<h4 id="feature_branches">feature branches</h4><p>May branch off from：develop</p>
<p>Must merge back into：develop</p>
<p>Branch naming convention:anything except master, develop, release-, or hotfix-</p>
<p>feature branches 是用来开发新功能的分支。当开发一个新功能时，开发者不确定什么时候能够上线。feature branches可以一直存在，直到代码提交被合并到develop或者丢弃。feature braches通常情况下只存在于开发者的本地代码库中，而不在远程库中。</p>
<p>feature branch的创建</p>
<pre><code>git checkout －<span class="tag">b</span> myfeature develop
</code></pre><p>在myfeature分支开发完成后，合并到develop分支，然后推送到远程库origin／develop中</p>
<pre><code>git checkout develop <span class="comment">//切换本地分支</span>
git <span class="keyword">merge</span> --<span class="keyword">no</span>-ff myfeature <span class="comment">//在本地进行合并操作</span>
git branch -<span class="keyword">d</span> myfeature <span class="comment">//删除myfeature分支</span>
git push origin develop <span class="comment">//推送到origin/develop</span>
</code></pre><p>–no-ff 是取消fast forward的意思，强制在合并的时候生成一个新的commit，即使在能够fast forword的情况下。这样能够防止丢失feature branch的信息，因为后面会删除这个feature branch，如果使用了fast forward，那么feature branch的信息就没了。</p>
<h4 id="release_branches">release branches</h4><p>May branch off from:develop</p>
<p>Must merge back into:develop &amp; master</p>
<p>Branch naming convention: release-*</p>
<p>release branch是为了协助代码上线的分支，可以在此分支上做测试、修复bug、该metadata信息等。</p>
<p>创建release branch</p>
<pre><code>git checkout -<span class="tag">b</span> release-<span class="number">1.2</span> develop
./bump-version<span class="class">.sh</span> <span class="number">1.2</span>
git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2"</span>
</code></pre><p>在这里可以做一些bug修复等小工作，不适合做包含大量代码修改的工作。当代码修改完毕并通过测试的时候，这时的代码已经可以上线了，先把代码合并到master分支，然后合并到develop分支</p>
<pre><code>git checkout <span class="keyword">master</span>
<span class="title">git</span> merge --no-ff release-<span class="number">1.2</span>
git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span>
git checkout develop
git merge --no-ff release-<span class="number">1.2</span>
git branch -d release-<span class="number">1.2</span>
</code></pre><h4 id="hotfix_branches">hotfix branches</h4><p>May branch off from:master</p>
<p>Must merge back into:develop&amp;master</p>
<p>Branch naming convention:hotfix-* </p>
<p>我的理解是hotfix branch的作用是可以进行紧急bug修复。创建一个hotfix branch</p>
<pre><code>git checkout -<span class="tag">b</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span> master
./bump-version<span class="class">.sh</span> <span class="number">1.2</span>.<span class="number">1</span>
git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2.1"</span>
</code></pre><p>像release branch一样，修复完bug之后，把commit合并到master和develop</p>
<pre><code>git checkout master
git merge --no-ff hotfix-<span class="number">1.2</span><span class="number">.1</span>
git tag -a <span class="number">1.2</span><span class="number">.1</span>
git checkout develop
git merge --no-ff hotfix-<span class="number">1.2</span><span class="number">.1</span>
git branch -d hotfix-<span class="number">1.2</span><span class="number">.1</span>
</code></pre><p>需要注意的是，如果此时有release branch，应该合并commit到release branch而不是develop branch</p>
<p>大体上这篇文章的内容就是这样。当我写到这里的时候，我发现我们组的实际情况其实是与这些有些冲突的，因此到底该怎么做，还是要做一番思考的。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="wys" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wys</p>
        </div>
        <p class="site-description motion-element" itemprop="description">I'm concerned with questions, not simply of immutable truth, but of practice and expedience.</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wys</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
